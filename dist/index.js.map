{"version":3,"sources":["../src/index.ts","../src/echoChamberClient.ts","../src/interactions.ts","../src/environment.ts","../src/types.ts"],"sourcesContent":["import { elizaLogger, type Client, type IAgentRuntime, type Plugin } from \"@elizaos/core\";\nimport { EchoChamberClient } from \"./echoChamberClient\";\nimport { InteractionClient } from \"./interactions\";\nimport type { EchoChamberConfig } from \"./types\";\nimport { validateEchoChamberConfig } from \"./environment\";\n\nexport const EchoChamberClientInterface: Client = {\n    name: \"echochamber\",\n    async start(runtime: IAgentRuntime) {\n        try {\n            // Validate configuration before starting\n            await validateEchoChamberConfig(runtime);\n\n            const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\n            const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\n\n            if (!apiKey || !apiUrl) {\n                throw new Error(\n                    \"ECHOCHAMBERS_API_KEY/ECHOCHAMBERS_API_URL is required\"\n                );\n            }\n\n            const config: EchoChamberConfig = {\n                apiUrl,\n                apiKey,\n                username:\n                    runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\n                    `agent-${runtime.agentId}`,\n                model: runtime.modelProvider,\n                rooms: runtime\n                    .getSetting(\"ECHOCHAMBERS_ROOMS\")\n                    ?.split(\",\")\n                    .map((r) => r.trim()) || [\"general\"],\n            };\n\n            elizaLogger.log(\"Starting EchoChambers client...\");\n\n            // Initialize the API client\n            const client = new EchoChamberClient(runtime, config);\n            await client.start();\n\n            // Initialize the interaction handler\n            const interactionClient = new InteractionClient(client, runtime);\n            await interactionClient.start();\n\n            elizaLogger.success(\n                `‚úÖ EchoChambers client successfully started for character ${runtime.character.name}`\n            );\n\n            return { client, interactionClient };\n        } catch (error) {\n            elizaLogger.error(\"Failed to start EchoChambers client:\", error);\n            throw error;\n        }\n    },\n\n    async stop(runtime: IAgentRuntime) {\n        try {\n            elizaLogger.warn(\"Stopping EchoChambers client...\");\n\n            // Get client instances if they exist\n            const clients = (runtime as any).clients?.filter(\n                (c: any) =>\n                    c instanceof EchoChamberClient ||\n                    c instanceof InteractionClient\n            );\n\n            for (const client of clients) {\n                await client.stop();\n            }\n\n            elizaLogger.success(\"EchoChambers client stopped successfully\");\n        } catch (error) {\n            elizaLogger.error(\"Error stopping EchoChambers client:\", error);\n            throw error;\n        }\n    },\n};\n\nexport const echoChambersPlugin: Plugin = {\n    name: \"echochambers\",\n    description:\n        \"Plugin for interacting with EchoChambers API to enable multi-agent communication\",\n    actions: [], // No custom actions needed - core functionality handled by client\n    evaluators: [], // No custom evaluators needed\n    providers: [], // No custom providers needed\n    clients: [EchoChamberClientInterface],\n};\n\nexport default echoChambersPlugin;\n\n// Export types and classes\nexport * from \"./types\";\nexport { EchoChamberClient } from \"./echoChamberClient\";\nexport { InteractionClient } from \"./interactions\";\n","import { elizaLogger, type IAgentRuntime } from \"@elizaos/core\";\nimport type {\n    ChatMessage,\n    ChatRoom,\n    EchoChamberConfig,\n    ModelInfo,\n    ListRoomsResponse,\n    RoomHistoryResponse,\n    MessageResponse,\n} from \"./types\";\n\nconst MAX_RETRIES = 3;\n\nconst RETRY_DELAY = 5000;\n\nexport class EchoChamberClient {\n    private runtime: IAgentRuntime;\n    private config: EchoChamberConfig;\n    private apiUrl: string;\n    private modelInfo: ModelInfo;\n    private watchedRooms: Set<string> = new Set();\n\n    constructor(runtime: IAgentRuntime, config: EchoChamberConfig) {\n        this.runtime = runtime;\n        this.config = config;\n        this.apiUrl = `${config.apiUrl}/api/rooms`;\n        this.modelInfo = {\n            username: config.username || `agent-${runtime.agentId}`,\n            model: config.model || runtime.modelProvider,\n        };\n    }\n\n    public getUsername(): string {\n        return this.modelInfo.username;\n    }\n\n    public getModelInfo(): ModelInfo {\n        return { ...this.modelInfo };\n    }\n\n    public getConfig(): EchoChamberConfig {\n        return { ...this.config };\n    }\n\n    private getAuthHeaders(): { [key: string]: string } {\n        return {\n            \"Content-Type\": \"application/json\",\n            \"x-api-key\": this.config.apiKey,\n        };\n    }\n\n    public async addWatchedRoom(roomId: string): Promise<void> {\n        try {\n            const rooms = await this.listRooms();\n            const room = rooms.find((r) => r.id === roomId);\n\n            if (!room) {\n                throw new Error(`Room ${roomId} not found`);\n            }\n\n            this.watchedRooms.add(roomId);\n            elizaLogger.success(`Now watching room: ${room.name}`);\n        } catch (error) {\n            elizaLogger.error(\"Error adding watched room:\", error);\n            throw error;\n        }\n    }\n\n    public removeWatchedRoom(roomId: string): void {\n        this.watchedRooms.delete(roomId);\n        elizaLogger.success(`Stopped watching room: ${roomId}`);\n    }\n\n    public getWatchedRooms(): string[] {\n        return Array.from(this.watchedRooms);\n    }\n\n    private async retryOperation<T>(\n        operation: () => Promise<T>,\n        retries: number = MAX_RETRIES\n    ): Promise<T> {\n        for (let i = 0; i < retries; i++) {\n            try {\n                return await operation();\n            } catch (error) {\n                if (i === retries - 1) throw error;\n                const delay = RETRY_DELAY * (2 ** i);\n                elizaLogger.warn(`Retrying operation in ${delay}ms...`);\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n        throw new Error(\"Max retries exceeded\");\n    }\n\n    public async start(): Promise<void> {\n        elizaLogger.log(\"üöÄ Starting EchoChamber client...\");\n        try {\n            await this.retryOperation(() => this.listRooms());\n\n            for (const room of this.config.rooms) {\n                await this.addWatchedRoom(room);\n            }\n\n            elizaLogger.success(\n                `‚úÖ EchoChamber client started for ${this.modelInfo.username}`\n            );\n            elizaLogger.info(\n                `Watching rooms: ${Array.from(this.watchedRooms).join(\", \")}`\n            );\n        } catch (error) {\n            elizaLogger.error(\"‚ùå Failed to start EchoChamber client:\", error);\n            throw error;\n        }\n    }\n\n    public async stop(): Promise<void> {\n        this.watchedRooms.clear();\n        elizaLogger.log(\"Stopping EchoChamber client...\");\n    }\n\n    public async listRooms(tags?: string[]): Promise<ChatRoom[]> {\n        try {\n            const url = new URL(this.apiUrl);\n            if (tags?.length) {\n                url.searchParams.append(\"tags\", tags.join(\",\"));\n            }\n\n            const response = await fetch(url.toString());\n            if (!response.ok) {\n                throw new Error(`Failed to list rooms: ${response.statusText}`);\n            }\n\n            const data = (await response.json()) as ListRoomsResponse;\n            return data.rooms;\n        } catch (error) {\n            elizaLogger.error(\"Error listing rooms:\", error);\n            throw error;\n        }\n    }\n\n    public async getRoomHistory(roomId: string): Promise<ChatMessage[]> {\n        return this.retryOperation(async () => {\n            const response = await fetch(`${this.apiUrl}/${roomId}/history`);\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to get room history: ${response.statusText}`\n                );\n            }\n\n            const data = (await response.json()) as RoomHistoryResponse;\n            return data.messages;\n        });\n    }\n\n    public async sendMessage(\n        roomId: string,\n        content: string\n    ): Promise<ChatMessage> {\n        return this.retryOperation(async () => {\n            const response = await fetch(`${this.apiUrl}/${roomId}/message`, {\n                method: \"POST\",\n                headers: this.getAuthHeaders(),\n                body: JSON.stringify({\n                    content,\n                    sender: this.modelInfo,\n                }),\n            });\n\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to send message: ${response.statusText}`\n                );\n            }\n\n            const data = (await response.json()) as MessageResponse;\n            return data.message;\n        });\n    }\n\n    public async shouldInitiateConversation(room: ChatRoom): Promise<boolean> {\n        try {\n            const history = await this.getRoomHistory(room.id);\n            if (!history?.length) return true; // Empty room is good to start\n\n            const recentMessages = history\n                .filter((msg) => msg != null) // Filter out null messages\n                .sort(\n                    (a, b) =>\n                        new Date(b.timestamp).getTime() -\n                        new Date(a.timestamp).getTime()\n                );\n\n            if (!recentMessages.length) return true; // No valid messages\n\n            const lastMessageTime = new Date(\n                recentMessages[0].timestamp\n            ).getTime();\n            const timeSinceLastMessage = Date.now() - lastMessageTime;\n\n            const quietPeriodSeconds = Number(\n                this.runtime.getSetting(\"ECHOCHAMBERS_QUIET_PERIOD\") || 300 // 5 minutes in seconds\n            );\n            const quietPeriod = quietPeriodSeconds * 1000; // Convert to milliseconds\n\n            if (timeSinceLastMessage < quietPeriod) {\n                elizaLogger.debug(\n                    `Room ${room.name} active recently, skipping`\n                );\n                return false;\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(`Error checking conversation state: ${error}`);\n            return false;\n        }\n    }\n}\n","import {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n} from \"@elizaos/core\";\nimport type { EchoChamberClient } from \"./echoChamberClient\";\nimport type { ChatMessage, ChatRoom } from \"./types\";\n\nfunction createMessageTemplate(currentRoom: string, roomTopic: string) {\n    return `\n# About {{agentName}}:\n{{bio}}\n{{lore}}\n{{knowledge}}\n\nCurrent Room: ${currentRoom}\nRoom Topic: ${roomTopic}\n\n{{messageDirections}}\n\nRecent conversation history:\n{{recentMessages}}\n\nThread Context:\n{{formattedConversation}}\n\n# Task: Generate a response in the voice and style of {{agentName}} while:\n1. Staying relevant to the room's topic\n2. Maintaining conversation context\n3. Being helpful but not overly talkative\n4. Responding naturally to direct questions or mentions\n5. Contributing meaningfully to ongoing discussions\n\nRemember:\n- Keep responses concise and focused\n- Stay on topic for the current room\n- Don't repeat information already shared\n- Be natural and conversational\n\n${messageCompletionFooter}`;\n}\n\nfunction createShouldRespondTemplate(currentRoom: string, roomTopic: string) {\n    return `\n# About {{agentName}}:\n{{bio}}\n{{knowledge}}\n\nCurrent Room: ${currentRoom}\nRoom Topic: ${roomTopic}\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} should:\n- RESPOND when:\n  * Directly mentioned or asked a question\n  * Can contribute relevant expertise to the discussion\n  * Topic aligns with their knowledge and background\n  * Conversation is active and engaging\n\n- IGNORE when:\n  * Message is not relevant to their expertise\n  * Already responded recently without new information to add\n  * Conversation has moved to a different topic\n  * Message is too short or lacks substance\n  * Other participants are handling the discussion well\n\n- STOP when:\n  * Asked to stop participating\n  * Conversation has concluded\n  * Discussion has completely diverged from their expertise\n  * Room topic has changed significantly\n\nRecent messages:\n{{recentMessages}}\n\nThread Context:\n{{formattedConversation}}\n\n# Task: Choose whether {{agentName}} should respond to the last message.\nConsider:\n1. Message relevance to {{agentName}}'s expertise\n2. Current conversation context\n3. Time since last response\n4. Value of potential contribution\n\n${shouldRespondFooter}`;\n}\n\nfunction createConversationStarterTemplate(\n    currentRoom: string,\n    roomTopic: string\n) {\n    return `\n# Room Context:\nRoom: ${currentRoom}\nTopic: ${roomTopic}\n\n# About {{agentName}}:\n{{bio}}\n{{lore}}\n{{knowledge}}\n\n# Task: Generate a conversation starter that:\n1. Is specifically relevant to the room's topic\n2. Draws from {{agentName}}'s knowledge\n3. Encourages discussion and engagement\n4. Is natural and conversational\n\nKeep it concise and focused on the room's topic.\n${messageCompletionFooter}`;\n}\n\nexport class InteractionClient {\n    private client: EchoChamberClient;\n    private runtime: IAgentRuntime;\n    private lastCheckedTimestamps: Map<string, string> = new Map();\n    private lastResponseTimes: Map<string, number> = new Map();\n    private messageThreads: Map<string, ChatMessage[]> = new Map();\n    private messageHistory: Map<\n        string,\n        { message: ChatMessage; response: ChatMessage | null }[]\n    > = new Map();\n    private pollInterval: NodeJS.Timeout | null = null;\n    private conversationStarterInterval: NodeJS.Timeout | null = null;\n\n    constructor(client: EchoChamberClient, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n    }\n\n    async start() {\n        const pollInterval = Number(\n            this.runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 60\n        );\n\n        const conversationStarterInterval = Number(\n            this.runtime.getSetting(\n                \"ECHOCHAMBERS_CONVERSATION_STARTER_INTERVAL\"\n            ) || 300\n        );\n\n        // Reactive message handling loop\n        const handleInteractionsLoop = () => {\n            this.handleInteractions();\n            this.pollInterval = setTimeout(\n                handleInteractionsLoop,\n                pollInterval * 1000\n            );\n        };\n\n        // Proactive conversation loop\n        const conversationStarterLoop = () => {\n            this.checkForDeadRooms();\n            this.conversationStarterInterval = setTimeout(\n                conversationStarterLoop,\n                conversationStarterInterval * 1000\n            );\n        };\n\n        handleInteractionsLoop();\n        conversationStarterLoop();\n    }\n\n    async stop() {\n        if (this.pollInterval) {\n            clearTimeout(this.pollInterval);\n            this.pollInterval = null;\n        }\n\n        if (this.conversationStarterInterval) {\n            clearTimeout(this.conversationStarterInterval);\n            this.conversationStarterInterval = null;\n        }\n    }\n\n    private async buildMessageThread(\n        message: ChatMessage,\n        messages: ChatMessage[]\n    ): Promise<ChatMessage[]> {\n        const thread: ChatMessage[] = [];\n        const maxThreadLength = Number(\n            this.runtime.getSetting(\"ECHOCHAMBERS_MAX_MESSAGES\") || 10\n        );\n\n        // Start with the current message\n        thread.push(message);\n\n        // Get recent messages in the same room, ordered by timestamp\n        const roomMessages = messages\n            .filter((msg) => msg.roomId === message.roomId)\n            .sort(\n                (a, b) =>\n                    new Date(b.timestamp).getTime() -\n                    new Date(a.timestamp).getTime()\n            );\n\n        // Add recent messages to provide context\n        for (const msg of roomMessages) {\n            if (thread.length >= maxThreadLength) break;\n            if (msg.id !== message.id) {\n                thread.unshift(msg);\n            }\n        }\n\n        return thread;\n    }\n\n    private shouldProcessMessage(\n        message: ChatMessage,\n        room: { topic: string }\n    ): boolean {\n        const modelInfo = this.client.getModelInfo();\n\n        // Don't process own messages\n        if (message.sender.username === modelInfo.username) {\n            return false;\n        }\n\n        // Check if we've processed this message before\n        const lastChecked =\n            this.lastCheckedTimestamps.get(message.roomId) || \"0\";\n        if (message.timestamp <= lastChecked) {\n            return false;\n        }\n\n        // Check rate limiting for responses\n        const lastResponseTime =\n            this.lastResponseTimes.get(message.roomId) || 0;\n        const minTimeBetweenResponses = 30000; // 30 seconds\n        if (Date.now() - lastResponseTime < minTimeBetweenResponses) {\n            return false;\n        }\n\n        // Check if message mentions the agent\n        const isMentioned = message.content\n            .toLowerCase()\n            .includes(`${modelInfo.username.toLowerCase()}`);\n\n        // Check if message is relevant to room topic\n        const isRelevantToTopic =\n            room.topic &&\n            message.content.toLowerCase().includes(room.topic.toLowerCase());\n\n        // Always process if mentioned, otherwise check relevance\n        return isMentioned || isRelevantToTopic;\n    }\n\n    private async handleInteractions() {\n        elizaLogger.log(\"Checking EchoChambers interactions\");\n\n        try {\n            // Get all watched rooms from the client\n            const watchedRooms = this.client.getWatchedRooms();\n            const rooms = await this.client.listRooms();\n\n            for (const room of rooms) {\n                // Only process messages from watched rooms\n                if (!watchedRooms.includes(room.id)) {\n                    continue;\n                }\n\n                const messages = await this.client.getRoomHistory(room.id);\n                this.messageThreads.set(room.id, messages);\n\n                // Get only the most recent message that we should process\n                const latestMessages = messages\n                    .filter((msg) => this.shouldProcessMessage(msg, room))\n                    .sort(\n                        (a, b) =>\n                            new Date(b.timestamp).getTime() -\n                            new Date(a.timestamp).getTime()\n                    );\n\n                if (latestMessages.length > 0) {\n                    const latestMessage = latestMessages[0];\n                    await this.handleMessage(latestMessage, room.topic);\n\n                    // Update history\n                    const roomHistory = this.messageHistory.get(room.id) || [];\n                    roomHistory.push({\n                        message: latestMessage,\n                        response: null,\n                    });\n                    this.messageHistory.set(room.id, roomHistory);\n\n                    // Update last checked timestamp\n                    if (\n                        latestMessage.timestamp >\n                        (this.lastCheckedTimestamps.get(room.id) || \"0\")\n                    ) {\n                        this.lastCheckedTimestamps.set(\n                            room.id,\n                            latestMessage.timestamp\n                        );\n                    }\n                }\n            }\n\n            elizaLogger.log(\"Finished checking EchoChambers interactions\");\n        } catch (error) {\n            elizaLogger.error(\n                \"Error handling EchoChambers interactions:\",\n                error\n            );\n        }\n    }\n\n    private async handleMessage(message: ChatMessage, roomTopic: string) {\n        try {\n            const content = `${message.content?.substring(0, 50)}...`; // First 50 chars\n            elizaLogger.debug(\"Processing message:\", {\n                id: message.id,\n                room: message.roomId,\n                sender: message?.sender?.username,\n                content: `${content}`,\n            });\n\n            const roomId = stringToUuid(message.roomId);\n            const userId = stringToUuid(message.sender.username);\n\n            elizaLogger.debug(\"Converted IDs:\", { roomId, userId });\n\n            // Ensure connection exists\n            await this.runtime.ensureConnection(\n                userId,\n                roomId,\n                message.sender.username,\n                message.sender.username,\n                \"echochambers\"\n            );\n\n            // Build message thread for context\n            const thread = await this.buildMessageThread(\n                message,\n                this.messageThreads.get(message.roomId) || []\n            );\n\n            // Create memory object\n            const memory: Memory = {\n                id: stringToUuid(message.id),\n                userId,\n                agentId: this.runtime.agentId,\n                roomId,\n                content: {\n                    text: message.content,\n                    source: \"echochambers\",\n                    thread: thread.map((msg) => ({\n                        text: msg.content,\n                        sender: msg.sender.username,\n                        timestamp: msg.timestamp,\n                    })),\n                },\n                createdAt: new Date(message.timestamp).getTime(),\n                embedding: getEmbeddingZeroVector(),\n            };\n\n            // Check if we've already processed this message\n            const existing = await this.runtime.messageManager.getMemoryById(\n                memory.id\n            );\n            if (existing) {\n                elizaLogger.log(\n                    `Already processed message ${message.id}, skipping`\n                );\n                return;\n            }\n\n            // Save the message to memory\n            await this.runtime.messageManager.createMemory(memory);\n\n            // Compose state with thread context\n            let state = await this.runtime.composeState(memory);\n            state = await this.runtime.updateRecentMessageState(state);\n\n            // Decide whether to respond\n            const shouldRespondContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.shouldRespondTemplate ||\n                    createShouldRespondTemplate(message.roomId, roomTopic),\n            });\n\n            const shouldRespond = await generateShouldRespond({\n                runtime: this.runtime,\n                context: shouldRespondContext,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (shouldRespond !== \"RESPOND\") {\n                elizaLogger.log(\n                    `Not responding to message ${message.id}: ${shouldRespond}`\n                );\n                return;\n            }\n\n            // Generate response\n            const responseContext = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.messageHandlerTemplate ||\n                    createMessageTemplate(message.roomId, roomTopic),\n            });\n\n            const response = await generateMessageResponse({\n                runtime: this.runtime,\n                context: responseContext,\n                modelClass: ModelClass.LARGE,\n            });\n\n            if (!response || !response.text) {\n                elizaLogger.log(\"No response generated\");\n                return;\n            }\n\n            // Send response\n            const callback: HandlerCallback = async (content: Content) => {\n                const sentMessage = await this.client.sendMessage(\n                    message.roomId,\n                    content.text\n                );\n\n                // Update last response time\n                this.lastResponseTimes.set(message.roomId, Date.now());\n\n                // Update history with our response\n                const roomHistory =\n                    this.messageHistory.get(message.roomId) || [];\n                const lastEntry = roomHistory[roomHistory.length - 1];\n                if (lastEntry && lastEntry.message.id === message.id) {\n                    lastEntry.response = sentMessage;\n                }\n\n                const responseMemory: Memory = {\n                    id: stringToUuid(sentMessage.id),\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    roomId,\n                    content: {\n                        text: sentMessage.content,\n                        source: \"echochambers\",\n                        action: content.action,\n                        thread: thread.map((msg) => ({\n                            text: msg.content,\n                            sender: msg.sender.username,\n                            timestamp: msg.timestamp,\n                        })),\n                    },\n                    createdAt: new Date(sentMessage.timestamp).getTime(),\n                    embedding: getEmbeddingZeroVector(),\n                };\n\n                await this.runtime.messageManager.createMemory(responseMemory);\n                return [responseMemory];\n            };\n\n            // Send the response and process any resulting actions\n            const responseMessages = await callback(response);\n            state = await this.runtime.updateRecentMessageState(state);\n            await this.runtime.processActions(\n                memory,\n                responseMessages,\n                state,\n                callback\n            );\n            await this.runtime.evaluate(memory, state, true);\n        } catch (error) {\n            elizaLogger.error(\"Error handling message:\", error);\n            elizaLogger.debug(\"Message that caused error:\", {\n                message,\n                roomTopic,\n            });\n        }\n    }\n\n    private async checkForDeadRooms() {\n        try {\n            const watchedRooms = this.client.getWatchedRooms();\n            elizaLogger.debug(\n                \"Starting dead room check. Watched rooms:\",\n                watchedRooms\n            );\n\n            const rooms = await this.client.listRooms();\n            elizaLogger.debug(\n                \"Available rooms:\",\n                rooms.map((r) => ({ id: r.id, name: r.name }))\n            );\n\n            for (const roomId of watchedRooms) {\n                try {\n                    elizaLogger.debug(`Checking room ${roomId}`);\n\n                    const room = rooms.find((r) => r.id === roomId);\n                    if (!room) {\n                        elizaLogger.debug(`Room ${roomId} not found, skipping`);\n                        continue;\n                    }\n\n                    // Log room details\n                    elizaLogger.debug(\"Room details:\", {\n                        id: room.id,\n                        name: room.name,\n                        topic: room.topic,\n                    });\n\n                    // Random check with logging\n                    const randomCheck = Math.random();\n                    elizaLogger.debug(\n                        `Random check for ${room.name}: ${randomCheck}`\n                    );\n\n                    if (randomCheck > 0.8) {\n                        elizaLogger.debug(\n                            `Checking conversation state for ${room.name}`\n                        );\n\n                        const shouldInitiate =\n                            await this.client.shouldInitiateConversation(room);\n                        elizaLogger.debug(\n                            `Should initiate conversation in ${room.name}:`,\n                            shouldInitiate\n                        );\n\n                        if (shouldInitiate) {\n                            elizaLogger.debug(\n                                `Starting conversation initiation in ${room.name}`\n                            );\n                            await this.initiateConversation(room);\n                            elizaLogger.debug(\n                                `Completed conversation initiation in ${room.name}`\n                            );\n                        }\n                    }\n                } catch (roomError: unknown) {\n                    // Log individual room errors without stopping the loop\n                    if (roomError instanceof Error) {\n                        elizaLogger.error(`Error processing room ${roomId}:`, {\n                            error: roomError.message,\n                            stack: roomError.stack,\n                        });\n                    } else {\n                        elizaLogger.error(`Error processing room ${roomId}:`, roomError);\n                    }\n                }\n            }\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                elizaLogger.error(\n                    \"Error in checkForDeadRooms:\",\n                    error.message || \"Unknown error\"\n                );\n                elizaLogger.debug(\"Full error details:\", {\n                    error,\n                    stack: error.stack,\n                    type: typeof error,\n                });\n            } else {\n                elizaLogger.error(\"Error in checkForDeadRooms:\", String(error));\n            }\n        }\n    }\n\n    private async initiateConversation(room: ChatRoom) {\n        try {\n            elizaLogger.debug(`Starting initiateConversation for ${room.name}`);\n\n            // Create a dummy memory instead of passing null\n            const dummyMemory: Memory = {\n                id: stringToUuid(\"conversation-starter\"),\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId,\n                roomId: stringToUuid(room.id),\n                content: {\n                    text: \"\",\n                    source: \"echochambers\",\n                    thread: [],\n                },\n                createdAt: Date.now(),\n                embedding: getEmbeddingZeroVector(),\n            };\n\n            const state = await this.runtime.composeState(dummyMemory);\n            elizaLogger.debug(\"Composed state for conversation\");\n\n            const context = composeContext({\n                state,\n                template: createConversationStarterTemplate(\n                    room.name,\n                    room.topic\n                ),\n            });\n            elizaLogger.debug(\"Created conversation context\");\n\n            const content = await generateMessageResponse({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n            elizaLogger.debug(\"Generated response content:\", {\n                hasContent: !!content,\n                textLength: content?.text?.length,\n            });\n\n            if (content?.text) {\n                elizaLogger.debug(`Sending message to ${room.name}`);\n                await this.client.sendMessage(room.id, content.text);\n                elizaLogger.info(\n                    `Started conversation in ${room.name} (Topic: ${room.topic})`\n                );\n            }\n        } catch (error: unknown) {\n            if (error instanceof Error) {\n                elizaLogger.error(\n                    `Error in initiateConversation for ${room.name}:`,\n                    {\n                        error: error.message,\n                        stack: error.stack,\n                    }\n                );\n            } else {\n                elizaLogger.error(\n                    `Error in initiateConversation for ${room.name}:`,\n                    String(error)\n                );\n            }\n            throw error; // Re-throw to be caught by parent\n        }\n    }\n}\n","import { type IAgentRuntime, elizaLogger } from \"@elizaos/core\";\n\nexport async function validateEchoChamberConfig(\n    runtime: IAgentRuntime\n): Promise<void> {\n    const apiUrl = runtime.getSetting(\"ECHOCHAMBERS_API_URL\");\n    const apiKey = runtime.getSetting(\"ECHOCHAMBERS_API_KEY\");\n\n    if (!apiUrl) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_API_URL is required. Please set it in your environment variables.\"\n        );\n        throw new Error(\"ECHOCHAMBERS_API_URL is required\");\n    }\n\n    if (!apiKey) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_API_KEY is required. Please set it in your environment variables.\"\n        );\n        throw new Error(\"ECHOCHAMBERS_API_KEY is required\");\n    }\n\n    // Validate API URL format\n    try {\n        new URL(apiUrl);\n    } catch {\n        elizaLogger.error(\n            `Invalid ECHOCHAMBERS_API_URL format: ${apiUrl}. Please provide a valid URL.`\n        );\n        throw new Error(\"Invalid ECHOCHAMBERS_API_URL format\");\n    }\n\n    // Optional settings with defaults\n    const username =\n        runtime.getSetting(\"ECHOCHAMBERS_USERNAME\") ||\n        `agent-${runtime.agentId}`;\n    // Change from DEFAULT_ROOM to ROOMS\n    const rooms = runtime.getSetting(\"ECHOCHAMBERS_ROOMS\")?.split(\",\").map(r => r.trim()) || [\"general\"];\n\n    const pollInterval = Number(\n        runtime.getSetting(\"ECHOCHAMBERS_POLL_INTERVAL\") || 120\n    );\n\n    if (Number.isNaN(pollInterval) || pollInterval < 1) {\n        elizaLogger.error(\n            \"ECHOCHAMBERS_POLL_INTERVAL must be a positive number in seconds\"\n        );\n        throw new Error(\"Invalid ECHOCHAMBERS_POLL_INTERVAL\");\n    }\n\n    elizaLogger.log(\"EchoChambers configuration validated successfully\");\n    elizaLogger.log(`API URL: ${apiUrl}`);\n    elizaLogger.log(`Username: ${username}`);\n    elizaLogger.log(`Watching Rooms: ${rooms.join(\", \")}`);\n    elizaLogger.log(`Poll Interval: ${pollInterval}s`);\n}\n","export interface ModelInfo {\n    username: string; // Unique username for the model/agent\n    model: string; // Type/name of the model being used\n}\n\nexport interface ChatMessage {\n    id: string; // Unique message identifier\n    content: string; // Message content/text\n    sender: ModelInfo; // Information about who sent the message\n    timestamp: string; // ISO timestamp of when message was sent\n    roomId: string; // ID of the room this message belongs to\n}\n\nexport interface ChatRoom {\n    id: string; // Unique room identifier\n    name: string; // Display name of the room\n    topic: string; // Room's current topic/description\n    tags: string[]; // Tags associated with the room for categorization\n    participants: ModelInfo[]; // List of current room participants\n    createdAt: string; // ISO timestamp of room creation\n    messageCount: number; // Total number of messages in the room\n}\n\nexport interface EchoChamberConfig {\n    apiUrl: string; // Base URL for the EchoChambers API\n    apiKey: string; // Required API key for authenticated endpoints\n    rooms: string[]; // list of rooms to listen on startup\n    username?: string; // Optional custom username (defaults to agent-{agentId})\n    model?: string; // Optional model name (defaults to runtime.modelProvider)\n}\n\nexport interface ListRoomsResponse {\n    rooms: ChatRoom[];\n}\n\nexport interface RoomHistoryResponse {\n    messages: ChatMessage[];\n}\n\nexport interface MessageResponse {\n    message: ChatMessage;\n}\n\nexport interface CreateRoomResponse {\n    room: ChatRoom;\n}\n\nexport interface ClearMessagesResponse {\n    success: boolean;\n    message: string;\n}\n\nexport enum RoomEvent {\n    MESSAGE_CREATED = \"message_created\",\n    ROOM_CREATED = \"room_created\",\n    ROOM_UPDATED = \"room_updated\",\n    ROOM_JOINED = \"room_joined\",\n    ROOM_LEFT = \"room_left\",\n}\n\nexport interface MessageTransformer {\n    transformIncoming(content: string): Promise<string>;\n    transformOutgoing?(content: string): Promise<string>;\n}\n\nexport interface ContentModerator {\n    validateContent(content: string): Promise<boolean>;\n}\n"],"mappings":"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","names":["elizaLogger","elizaLogger","content","elizaLogger","RoomEvent","elizaLogger"]}